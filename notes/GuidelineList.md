# Guideline 1: Understand the Importance of Software Design
* Focus less on C++ language details and more on software design
* Understand software design as the art of managing dependencies and abstractions
# Guideline 2: Design for Change
* Adhere to the Single-Responsibility Principle (SRP) to separate concerns
* Follow the Don’t Repeat Yourself (DRY) principle to minimize duplication.
# Guideline 3: Separate Interfaces to Avoid Artificial Coupling
* Adhere to the Interface Segregation Principle (ISP) to separate concerns in interfaces.
* Consider the ISP as a special case of the Single-Responsibility Principle (SRP).
# Guideline 4: Design for Testability
# Guideline 5: Design for Extension
# Guideline 6: Adhere to the Expected Behavior of Abstractions
# Guideline 7: Understand the Similarities Between Base Classes and Concepts
# Guideline 8: Understand the Semantic Requirements of Overload Sets
# Guideline 9: Pay Attention to the Ownership of Abstractions
# Guideline 10: Consider Creating an Architectural Document
# Guideline 11: Understand the Purpose of Design Patterns
# Guideline 12: Beware of Design Pattern Misconceptions
# Guideline 13: Design Patterns Are Everywhere
# Guideline 14: Use a Design Pattern’s Name to Communicate Intent
# Guideline 15: Design for the Addition of Types or Operations
# Guideline 16: Use Visitor to Extend Operations
# Guideline 17: Consider std::variant for Implementing Visitor
# Guideline 18: Beware the Performance of Acyclic Visitor
# Guideline 19: Use Strategy to Isolate How Things Are Done
# Guideline 20: Favor Composition over Inheritance
# Guideline 21: Use Command to Isolate What Things Are Done
# Guideline 22: Prefer Value Semantics over Reference Semantics
# Guideline 23: Prefer a Value-Based Implementation of Strategy and Command
# Guideline 24: Use Adapters to Standardize Interfaces
# Guideline 25: Apply Observers as an Abstract Notification Mechanism
# Guideline 26: Use CRTP to Introduce Static Type Categories
# Guideline 27: Use CRTP for Static Mixin Classes
# Guideline 28: Build Bridges to Remove Physical Dependencies
# Guideline 29: Be Aware of Bridge Performance Gains and Losses
# Guideline 30: Apply Prototype for Abstract Copy Operations
# Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism
# Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure
# Guideline 33: Be Aware of the Optimization Potential of Type Erasure
# Guideline 34: Be Aware of the Setup Costs of Owning Type Erasure Wrappers
# Guideline 35: Use Decorators to Add Customization Hierarchically
# Guideline 36: Understand the Tradeoff Between Runtime and Compile Time Abstraction
# Guideline 37: Treat Singleton as an Implementation Pattern, Not a Design Pattern
# Guideline 38: Design Singletons for Change and Testability
# Guideline 39: Continue to Learn About Design Patterns
